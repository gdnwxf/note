### 红黑树的实现

**本文基于java的TreeMap分析**

```java
/**
 *            p                *           p
 *         /     \             *         /   \
 *      pl (入参p) pr (y)       *      x2(r色)   pr (y)
 *    /  \                     *    /  \
 *  x1    x2 (r色)               *  pl(x)    x2r
 *       /  \                  *  / \
 *      x2l  x2r               * x1  x2l
 *  rotateLeft(x)              *  rotateLeft(x)
 *  入参是x 的 parent
 */
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> r = p.right;// 记录 p.right
        p.right = r.left;    //@1
        if (r.left != null)        // r不是叶子节点 则将r的左孩子的父节点设置成p
            r.left.parent = p;
        r.parent = p.parent; //@2

        {
            if (p.parent == null)         //p 是根节点      //处理边界
                root = r;                                  //处理边界
            else if (p.parent.left == p)  //p 是左子树      //处理边界
                p.parent.left = r;                         //处理边界
            else                          //p 是右子树      //处理边界
                p.parent.right = r;
        }

        r.left = p;          //@3
        p.parent = r;        //@4
    }
}

/** From CLR */
private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        TreeMap.Entry<K,V> l = p.left;
        p.left = l.right;
        if (l.right != null) l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)          //处理了边界
            root = l;                  //处理了边界
        else if (p.parent.right == p)  //处理了边界
            p.parent.right = l;        //处理了边界
        else p.parent.left = l;        //处理了边界
        l.right = p;
        p.parent = l;
    }
}


/**
 * 红黑树性质
 * 1 每个节点是红色, 或者黑色
 * 2 根节点是黑色
 * 3 每个叶子节点(nil)是黑色的
 * 4 如果一个节点是红色, 则它的2个子节点都是黑色的
 * 5 对每个节点,从该节点到其所有叶子节点的简单路径上,均包含相同数目的黑色节点
 */

/** From CLR */
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED; //插入的节点被标记为红色 , 这样移动的次数比较少
    /**
     *
     *
     *
     *
     *
     */
    //非跟节点 且父节点的颜色是红色的时候 需要调整树结构
    while (x != null && x != root && x.parent.color == RED) {
        //当 x.p.p.l = x.p 也就是其父节点是祖父节点的左孩子节点的时候
        /**
         *          p
         *        /  \
         *      pl    pr (y)
         *    /  \
         *  x1    x2
         *  x 为x1 或则 x2 , pr 为 y
         *  如果 pr == red
         *      set pl= black
         *      set pr = black
         *      set p = black
         *
         *  如果 pr == black 且 x = x2
         */
        // 其父节点是祖父节点左孩子
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            //如果uncle节点是红色
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);  //设置父节点黑色
                setColor(y, BLACK);   // 设置uncle节点黑色
                setColor(parentOf(parentOf(x)), RED);//设置祖父节点黑色
                x = parentOf(parentOf(x)); //
            //如果uncle节点是黑色
            } else {
                /** From CLR */
                if (x == rightOf(parentOf(x))) { // 如果x是右节点
                    x = parentOf(x); //x 设置成父节点
                    rotateLeft(x); //左旋父节点
                }
                setColor(parentOf(x), BLACK);  // 将原来出入节点设置成黑色
                setColor(parentOf(parentOf(x)), RED);//将插入节点的父节点设置成红色
                rotateRight(parentOf(parentOf(x))); //右旋原来节点的父节点
            }
        // 其父节点是是祖父节点右孩子的情况 与上面正好想反
        } else {
            // 取出uncle节点进行判断
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            // uncle节点是红色
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);// 设置父节点黑色
                setColor(y, BLACK);//uncle节点黑色
                setColor(parentOf(parentOf(x)), RED);//设置祖父节点红色
                x = parentOf(parentOf(x));  //
            // uncle节点是黑色
            } else {
                // 如果自己是父节点左孩子节点
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);//取出父节点
                    rotateRight(x);//右旋父节点
                }
                setColor(parentOf(x), BLACK);//设置插入节点的父节点黑色
                setColor(parentOf(parentOf(x)), RED);//设置插入节点的祖父节点黑色
                rotateLeft(parentOf(parentOf(x))); //左旋插入节点的祖父节点
            }
        }
    }
    root.color = BLACK; // 无论如何 root节点的颜色一定是黑色的
}
```

### 删除操作

```java
public V remove(Object key) {
    Entry<K,V> p = getEntry(key);
    if (p == null)
        return null;

    V oldValue = p.value;
    deleteEntry(p);
    return oldValue;//返回旧值
}
```

####查找后继节点

```java
/**
 * Returns the successor of the specified Entry, or null if no such.
 * 返回后继节点  
 * 先从右边节点起找
 * 再从父节点找
 */
static <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {
    if (t == null)
        return null;
    // 先从右边节点起找, 直到最左叶子节点
    else if (t.right != null) {
        Entry<K,V> p = t.right;
        while (p.left != null)
            p = p.left;
        return p;
      //自己的右孩子为空
    } else {
        Entry<K,V> p = t.parent;
        Entry<K,V> ch = t;
      //如果自己不是右节点 直接把parent返回
      //如果自己是右节点 则一直向上查找父节点直到自己不为右节点为止 或者知道根节点
      /** 
       * 返回的是根节点 或者自己做为右树节点的根分支
       */
        while (p != null && ch == p.right) {
            ch = p;
            p = p.parent;
        }
        return p;
    }
}
```

###真正的删除开始

```java
/**
 * Delete node p, and then rebalance the tree.
 */
private void deleteEntry(Entry<K,V> p) {
    modCount++;
    size--;

    // If strictly internal, copy successor's element to p and then make p
    // point to successor.
    if (p.left != null && p.right != null) {
        /** 
         * 返回的是 successor 的第二种情况 即 p.right != null
         */
        Entry<K,V> s = successor(p);
        p.key = s.key;
        p.value = s.value;
        p = s;
    } // p has 2 children

    // Start fixup at replacement node, if it exists.
    // 判断孩子节点哪个不是null的
    Entry<K,V> replacement = (p.left != null ? p.left : p.right);

    if (replacement != null) {
        // Link replacement to parent
        replacement.parent = p.parent;
        if (p.parent == null)
            root = replacement;
        else if (p == p.parent.left)
            p.parent.left  = replacement;
        else
            p.parent.right = replacement;

        // Null out links so they are OK to use by fixAfterDeletion.
        p.left = p.right = p.parent = null;

        // Fix replacement
        if (p.color == BLACK)
            fixAfterDeletion(replacement);
      // 如果自己就是根节点 则不用改任何的东西
    } else if (p.parent == null) {  // return if we are the only node.
        root = null;
      // 如果没有孩子节点
    } else { //  No children. Use self as phantom replacement and unlink.
        if (p.color == BLACK) //将自己颜色设置成黑色
            fixAfterDeletion(p);

        if (p.parent != null) {
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}
```

###删除节点的旋转处理

```java
/** From CLR */
private void fixAfterDeletion(Entry<K,V> x) {
    while (x != root && colorOf(x) == BLACK) {
        //当删除节点为父节点的左孩子节点时 
        if (x == leftOf(parentOf(x))) {
           //获取父节点的右孩子节点 即x的兄弟节点
            Entry<K,V> sib = rightOf(parentOf(x));
						//if兄弟是红色
            if (colorOf(sib) == RED) {
                setColor(sib, BLACK); // 设置兄弟黑色
                setColor(parentOf(x), RED);//设置父节点红色
                rotateLeft(parentOf(x));//左旋父节点
                sib = rightOf(parentOf(x));//再次获取现在父节点的右节点,此时的右节点左旋前x的(右)兄弟节点的左孩子节点
            }
           	// 以上保证了兄弟节点是黑色的
						// 判断兄弟节点的孩子节点是否都是黑色
            if (colorOf(leftOf(sib))  == BLACK &&
                colorOf(rightOf(sib)) == BLACK) {
              //设置兄弟节点为红色
                setColor(sib, RED);
              //x设置成父节点
                x = parentOf(x);
            } else {
              //当兄弟节点右孩子节点为黑色时
                if (colorOf(rightOf(sib)) == BLACK) {
                  // 设置左孩子节点也为黑色
                    setColor(leftOf(sib), BLACK);
                  // 设置兄弟节点(父节点)为红色
                    setColor(sib, RED);
                  // 右旋兄弟节点
                    rotateRight(sib);
                  // 将父节点设置成 删除节点的右孩子
                    sib = rightOf(parentOf(x));
                }
              // 设置父节点和删除节点的一样的颜色
                setColor(sib, colorOf(parentOf(x)));
              // 设置删除节点为黑色
                setColor(parentOf(x), BLACK);
              // 设置父节点的右节点为黑色
                setColor(rightOf(sib), BLACK);
              // 左旋删除节点的父节点
                rotateLeft(parentOf(x));
                x = root;
            }
          //删除的节点是父节点的右孩子节点
        } else { // symmetric
          // 获取左孩子节点 即x的兄弟节点
            Entry<K,V> sib = leftOf(parentOf(x));
						//如果左孩子节点为红色
            if (colorOf(sib) == RED) {
              // 设置左孩子节点为黑色
                setColor(sib, BLACK);
              // 设置删除节点的父节点为红色
                setColor(parentOf(x), RED);
              // 右旋当前节点的父节点
                rotateRight(parentOf(x));
              // sib 设置成当前删除节点的父节点 (右于发生了右旋 原来的父节点变成了删除节点的右孩子)
                sib = leftOf(parentOf(x));
            }
            // 以上条件保证兄弟节点始终是黑色
						// 兄弟节点的左右孩子都是黑色的时候
            if (colorOf(rightOf(sib)) == BLACK &&
                colorOf(leftOf(sib)) == BLACK) {
              // 设置兄弟节点为红色
                setColor(sib, RED);
              // 将x 设置成现在的父节点
                x = parentOf(x);
            } else {
              // 当兄弟节点的左孩子节点是黑色时
                if (colorOf(leftOf(sib)) == BLACK) {
                  // 设置兄弟节点的右孩子为黑色
                    setColor(rightOf(sib), BLACK);
                  // 设置兄弟节点为红色
                    setColor(sib, RED);
                  // 左旋兄弟节点
                    rotateLeft(sib);
                  // 将sib 重新设置为旋转之后的兄弟节点
                    sib = leftOf(parentOf(x));
                }
              // 设置兄弟节点和父节点颜色相同
                setColor(sib, colorOf(parentOf(x)));
              // 设置父节点为黑色
                setColor(parentOf(x), BLACK);
              // 设置兄弟节点的左孩子节点为黑色
                setColor(leftOf(sib), BLACK);
              // 右旋父节点
                rotateRight(parentOf(x));
              // 将当前节点置位root
                x = root;
            }
        }
    }
		//设置根节点为黑色
    setColor(x, BLACK);
}
```



##### 注:

> 参考 <https://www.cnblogs.com/CarpenterLee/p/5503882.html>