cobar服务端 源码分析
schame rute 等信息的配置
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
服务端入口 CobarStartup
	CobarServer server = CobarServer.getInstance();
	--> CobarServer INSTANCE = new CobarServer();
		--> this.config = new CobarConfig();
			--> ConfigInitializer confInit = new ConfigInitializer(); 实例化配置文件
----------------------------------------------------实例化schema信息----------------------------------------------------			
				--> SchemaLoader schemaLoader = new XMLSchemaLoader(); 实例化配置文件
				--> XMLConfigLoader configLoader = new XMLConfigLoader(schemaLoader);
					--> XMLServerLoader serverLoader = new XMLServerLoader();
						--> XMLServerLoader.load() // server.xml 文件中内容
							--> loadSystem(root); // 实例化系统的参数等信息
							--> loadUsers(root); //实例化用户 密码 以及 访问的 schemas 
							--> XMLServerLoader.cluster = new ClusterConfig(root, system.getServerPort()); 实例化集群配置 
								--> ClusterConfig.nodes = Map<String, CobarNodeConfig> loadNode(Element root,system.getServerPort()) //实例化nodes的信息
								--> ClusterConfig.groups = Map<String, List<String>> loadGroup(Element root,ClusterConfig.nodes) //实力化group的信息
----------------------------------------------------实例化routerule信息----------------------------------------------------
				--> RouteRuleInitializer.initRouteRule(schemaLoader); 实例化处理RouteRule
				--> ConfigInitializer.dataNodes = initDataNodes(configLoader);
					--> ConfigInitializer.dataNodes [Map<String, MySQLDataNode>]  <-- ClusterConfig.nodes
						--> dataNodes = new HashMap<String, MySQLDataNode>(nodeConfs.size()) 
							--> dataNode = new MySQLDataNode(dnc);	
							--> dsList = new MySQLDataSource[dsNames.length];
							--> dataNode.setSources(dsList); // 设置每个节点的数据源
						--> dataNodes.put(dataNode.getName(), dataNode); // 将
				--> this.cluster = initCobarCluster(configLoader);
					--> ConfigInitializer.cluster = new CobarCluster(configLoader.getClusterConfig())
						--> CobarCluster.nodes = new CobarNode(conf);
							--> new CobarHeartbeat(this) // 集群中每个节点的心跳的信息
								--> this.factory = new CobarDetectorFactory(); // 网络心跳Detector
									--> CobarDetectorFactory.make 创建网络连接
										--> SocketChannel channel = openSocketChannel(); // 打开网络channel
										--> new CobarDetector(channel); //
									--> CobarDetector.heartbeat() //发送心跳
								--> this.recorder = new HeartbeatRecorder(); 心跳记录信息 做统计使用的
reactor 模型启动
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			server.startup(); //启动服务
			--> new NIOProcessor[system.getProcessors()]; 实例化NIOProcessor 线程池 启动processor 同时也是 实例化NIOReactor
			--> processors[i].startup(); 启动处理线程
			--> timer.schedule(processorCheck(), 0L, system.getProcessorCheckPeriod()); 定时执行该方法，回收部分资源
启动后端的connector---------------------------------------------------------------------------------------------------------------------------------  
			--> NIOConnector connector = new NIOConnector(NAME + "Connector");  启动connector 
			--> connector.setProcessors(processors); // 设置实例化的处理器 [ selectionKey.attach(theObject); selectionKey 附加到某个键上]
    		--> connector.start(); //启动reactor 模型 
启动zookeeper对后端节点的监听------------------------------------------------------------------------------------------------------------------------ 
    		--> zookeeperManager = ZookeeperManager.getInstance(); 实例化zk client /cobar/{clusterName}/datasource 节点
    		--> listenAndDoSwitch(this.datasourceConf); 监听该节点下childEvent
    		--> for (MySQLDataNode node : dataNodes.values()) node.init(1, 0); //实例化每个节点
    			--> this.initZookeeperData() //初始化分布式锁等ZK协调元数据  xxxxx/datasource/dataNode.name  xxxxx/lock/dataNode.name 
    		--> timer.schedule(dataNodeIdleCheck() x,x)数据节点定时连接空闲超时检查任务
    		--> timer.schedule(dataNodeHeartbeat() x,x)数据节点定时心跳任务
启动前端front的链接的管理---------------------------------------------------------------------------------------------------------------------------------  
    		--> ManagerConnectionFactory mf = new ManagerConnectionFactory(); 实例化manager
    		--> ServerConnectionFactory sf = new ServerConnectionFactory(); 实例化ServerConnection
    		--> server = new NIOAcceptor(NAME + "Server", system.getServerPort(), sf);
    		--> server.start();
    		--> timer.schedule(clusterHeartbeat(),x,x) 
    		--> doDoubleCheckHeartBeat(); 检查delay的节点的心跳
    		--> scheduledExecutorService.scheduleAtFixedRate(new PerformanceDataSender(),x,x) 将收集到的信息发送到前端即 cobar-manager
		


调用链
	 NIOAcceptor.run() 
	 	-> accept(); 获取 SelectionKey
	 		-> SocketChannel channel = serverChannel.accept(); 在selectkeys 中获取sc
	 		-> FrontendConnection c = factory.make(channel);   实例化FC	
	 		-> NIOProcessor processor = nextProcessor();	   Round-Robin 方式选则Processor
	 		-> processor.postRegister(c);					   注册到Reactor 中去
	 			-> 到NIOReactor 注册读事件
	 				-> AbstractConnection.read
	 					-> FrontendConnection.handle
	 						-> FrontendAuthenticator.handle  	前段认证 校验用户等的信息
	 						-> success(auth);					通过认证, 设置后端
	 							-> source.setHandler(new FrontendCommandHandler(source));  注册回调  重新设置handler 为第二次读做准备, 处理MySQL 返回的读
	 							-> source.write(source.writeToBuffer(AUTH_OK, buffer));    写入->
	 								-> NIOReactor.W.write
	 								-> AbstractConnection.writeByEvent 唤醒写事件
	 								-> NIOReactor.R.write
	FrontendCommandHandler.handle
		-> @Override
	    public void handle(byte[] data) {
	        switch (data[4]) {
	        case MySQLPacket.COM_INIT_DB:
	            commands.doInitDB();
	            source.initDB(data);
	            break;
	        case MySQLPacket.COM_QUERY:
	            commands.doQuery();
	            source.query(data);
	            break;
	        case MySQLPacket.COM_PING:
	            commands.doPing();
	            source.ping();
	            break;
	        case MySQLPacket.COM_QUIT:
	            commands.doQuit();
	            source.close();
	            break;
	        case MySQLPacket.COM_PROCESS_KILL:
	            commands.doKill();
	            source.kill(data);
	            break;
	        case MySQLPacket.COM_STMT_PREPARE:
	            commands.doStmtPrepare();
	            source.stmtPrepare(data);
	            break;
	        case MySQLPacket.COM_STMT_EXECUTE:
	            commands.doStmtExecute();
	            source.stmtExecute(data);
	            break;
	        case MySQLPacket.COM_STMT_CLOSE:
	            commands.doStmtClose();
	            source.stmtClose(data);
	            break;
	        case MySQLPacket.COM_HEARTBEAT:
	            commands.doHeartbeat();
	            source.heartbeat(data);
	            break;
	        default:
	            commands.doOther();
	            source.writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Unknown command");
	    ->  FrontendConnection.query(sql)
	    	-> ServerQueryHandler.query(sql)
	    		-> SelectHandler.handle(stmt,ServerConnection,offs)
	    			-> ServerConnection.execute(sql, type)
	    				-> SchemaConfig schema = CobarServer.getInstance().getConfig().getSchemas().get(db);
	    				-> RouteResultset rrs = ServerRouter.route(schema, sql, this.charset, this); // 拆分sql 设置结果集  设置节点等的信息
	    					-> RouteResultset rrs = new RouteResultset(stmt);//route ResultSet
	    					// 检查是否含有cobar hint
        					-> int prefixIndex = HintRouter.indexOfPrefix(stmt);
	    				-> BlockingSession.execute(rrs, type); // blockingsession是指mysql的connection 是blocking 的

